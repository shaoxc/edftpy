{
	"JOB": {
		"comment": {
			"type": "str",
			"default": "Control of the running job."
		},
		"task": {
			"type": "cstr",
			"default": "Optdensity",
			"comment": "The task to be performed. Optdensity solves for the electronic structure to selfconsistency. Calculation performs a one-shot evaluation of calctype (see below) without selconsistency.",
			"options": "Optdensity, Calculation, Tddft, Optmix"
		},
		"calctype": {
			"type": "cstrlist",
			"default": "Energy",
			"comment": "The property to be calculated.",
			"options": "Energy, Potential, Force, Stress"
		}
	},
	"PATH": {
		"comment": {
			"type": "str",
			"default": "Specify the path of needed files."
		},
		"pp": {
			"comment": "The path of pseudopotential.",
			"options": "",
			"type": "str",
			"default": "./"
		},
		"cell": {
			"comment": "The path of input structure.",
			"options": "",
			"type": "str",
			"default": "./"
		}
	},
	"MATH": {
		"dftpy": {
			"type": "str",
			"default": "math",
			"comment": "twostep, multistep, reuse"
		}
	},
	"PP": {
		"comment": "Pseudopotential files for each atomic species",
		"type": "cdict",
		"default": {},
		"example": "Al = Al_lda.oe01.recpot"
	},
	"OUTPUT": {
		"comment": {
			"type": "str",
			"default": "Control the output."
		},
		"dftpy": {
			"type": "str",
			"default": "output",
			"comment": "stress"
		},
		"electrostatic_potential": {
			"type": "str",
			"default": null,
			"comment": "Output of electrostatic_potential."
		},
		"sub_temp": {
			"type": "bool",
			"default": false,
			"options": "True, False",
			"comment": "Output all the temporary files of subsystems."
		},
		"append": {
			"type": "bool",
			"default": false,
			"comment": "Append the output of all the subsystems."
		}
	},
	"OPT": {
		"comment": {
			"type": "str",
			"default": "Control the charge density optimization of global system."
		},
		"method": {
			"type": "str",
			"options": "Normal",
			"default": "Normal",
			"comment": "Charge density optimization method."
		},
		"econv": {
			"type": "float",
			"default": 1e-05,
			"comment": "Convergence threshold for energy, it will divided by the number of atoms.",
			"unit": "a.u./atom"
		},
		"pconv": {
			"type": "float",
			"default": null,
			"comment": "Convergence threshold for potential. Default is 'econv'/1E2.",
			"unit": "a.u/atom"
		},
		"maxiter": {
			"type": "int",
			"default": 100,
			"comment": "The max steps for optimization."
		},
		"ncheck": {
			"type": "int",
			"comment": "How many step satisfy the convergence.",
			"default": 2
		},
		"olevel": {
			"type": "int",
			"comment": "The level of output energy, large will faster.",
			"note": "Only set 0, the energy of each cycle is useful.",
			"default": 2
		},
		"sdft": {
			"type": "str",
			"options": "sdft, pdft",
			"comment": "Subsystem DFT or Partition DFT.",
			"level": "devel",
			"default": "sdft"
		},
		"maxtime": {
			"type": "float",
			"comment": "Maximum execution time. Non-positive number means no time limit.",
			"unit": "second",
			"default": 0
		},
		"voltage": {
			"type": "float",
			"default": null,
			"comment": "The voltage between first and second subsystems.",
			"unit": "a.u"
		}
	},
	"TD": {
		"comment": {
			"type": "str",
			"default": "Control the TDDFT."
		},
		"maxiter": {
			"type": "int",
			"default": 1000,
			"comment": "The max steps for TDDFT."
		},
		"olevel": {
			"type": "int",
			"comment": "The level of output energy, large will faster.",
			"note": "Only set 0, the energy of each cycle is useful.",
			"default": 2
		},
		"sdft": {
			"type": "str",
			"options": "sdft, pdft",
			"comment": "Subsystem DFT or Partition DFT.",
			"level": "devel",
			"default": "sdft"
		},
		"restart": {
			"type": "str",
			"options": "initial, scf, restart",
			"comment": "Start the job from new one, scf results or restart from previous run.",
			"default": "initial"
		},
		"iter": {
			"type": "int",
			"options": "",
			"comment": "The iteration number of restart.",
			"default": "0"
		},
		"timestep": {
			"type": "float",
			"options": "",
			"comment": "The time step for TDDFT (as).",
			"unit": "attosecond",
			"level": "devel",
			"default": "1"
		},
		"maxtime": {
			"type": "float",
			"comment": "Maximum execution time. Non-positive number means no time limit.",
			"unit": "second",
			"default": 0
		}
	},
	"GSYSTEM": {
		"cell": {
			"dftpy": {
				"type": "str",
				"default": "cell",
				"comment": "cellfile"
			},
			"file": {
				"type": "str",
				"default": null
			},
			"lattice": {
				"type": "floatlist",
				"default": null,
				"comment": "Three numbers means three lengths of orthogonal cell; Six numbers means three vector lengths and three angles; Nine numbers means unit vector[a, b, c]. Only works for :ref:`GSYSTEM<GSYSTEM>` and when :ref:`cell-file<cell-file>` is not given.",
				"options": ""
			},
			"symbols": {
				"type": "cstrlist",
				"default": null,
				"comment": "A list of symbols for all atoms. Only works for :ref:`GSYSTEM<GSYSTEM>` and when :ref:`cell-file<cell-file>` is not given.",
				"options": ""
			},
			"positions": {
				"type": "floatlist",
				"default": null,
				"comment": "Atomic positions in Cartesian coordinate. Only works for :ref:`GSYSTEM<GSYSTEM>` and when :ref:`cell-file<cell-file>` is not given.",
				"unit": "Angstrom",
				"options": ""
			},
			"scaled_positions": {
				"type": "floatlist",
				"default": null,
				"comment": "Atomic positions in crystal coordinate. Only works for :ref:`GSYSTEM<GSYSTEM>` and when :ref:`cell-file<cell-file>` is not given.",
				"options": ""
			},
			"numbers": {
				"type": "intlist",
				"default": null,
				"comment": "Atomic number for all atoms. Only works for :ref:`GSYSTEM<GSYSTEM>` and when :ref:`cell-file<cell-file>` is not given.",
				"options": ""
			}
		},
		"grid": {
			"dftpy": {
				"type": "str",
				"default": "grid"
			},
			"optfft": {
				"type": "bool",
				"default": true,
				"comment": "Optimize the number of grid points."
			}
		},
		"density": {
			"comment": {
				"type": "str",
				"default": "Control the charge density."
			},
			"nspin": {
				"comment": "non/spin-polarized calculation.",
				"options": "1, 2",
				"type": "int",
				"level": "devel",
				"default": 1
			},
			"ncharge": {
				"type": "float",
				"comment": "Total charge of the system.",
				"level": "devel",
				"default": null
			},
			"magmom": {
				"type": "float",
				"comment": "Total electronic magnetization.",
				"level": "devel",
				"default": 0
			},
			"file": {
				"type": "str",
				"options": "",
				"comment": "The input density file for initial density.",
				"default": null
			},
			"output": {
				"type": "str",
				"options": "",
				"comment": "The output file or format of density. The name starts with '.' represent the format.",
				"default": null
			}
		},
		"exc": {
			"dftpy": {
				"type": "str",
				"default": "exc"
			},
			"dftd4": {
				"comment": "The method of dftd4_. If use it, the dftd4_ should be installed. See `dftd4's available methods <https://github.com/dftd4/dftd4/blob/main/assets/parameters.toml>`_.",
				"options": "",
				"type": "str",
				"note": "If dftd4='same', which means dftd4 use same functional as exchange-correlation.",
				"default": null
			},
			"libxc": {
				"comment": "The type of exchange-correlation functionals with pylibxc_.",
				"options": "",
				"type": "lstrlist",
				"default": "gga_x_pbe  gga_c_pbe"
			}
		},
		"kedf": {
			"dftpy": {
				"type": "str",
				"default": "kedf"
			},
			"kedf": {
				"type": "str",
				"default": "GGA_REVAPBEK"
			},
			"interp": {
				"type": "str",
				"default": "linear"
			},
			"delta": {
				"type": "float",
				"default": 0.3
			},
			"kdd": {
				"type": "int",
				"default": 1
			}
		},
		"mix": {
			"comment": {
				"type": "str",
				"default": "Control the charge density mixing."
			},
			"dftpy": {
				"type": "str",
				"default": "mix"
			},
			"scheme": {
				"type": "str",
				"default": null,
				"comment": "Density mixing scheme.",
				"options": "Pulay, Linear"
			}
		},
		"decompose": {
			"comment": {
				"type": "str",
				"default": "The way to decompose the subsystem to more subsystems"
			},
			"method": {
				"type": "str",
				"default": "manual",
				"comment": "'manual' means use the given subsystem; 'distance' means base on the distance of atoms to decompose the subsystem.",
				"options": "manual, distance"
			},
			"adaptive": {
				"type": "str",
				"default": "manual",
				"comment": "The decompose method after first step, 'manual' will remove all 'NSUB'.",
				"options": "manual, distance"
			},
			"rcut": {
				"type": "float",
				"default": 3,
				"comment": "The cutoff for decompose the subsystems.",
				"unit": "Angstrom"
			},
			"radius": {
				"type": "cfdict",
				"default": {},
				"comment": "The radius of each elements for decompose the subsystems.",
				"unit": "Angstrom"
			},
			"rtol": {
				"type": "float",
				"default": 0.0,
				"comment": "The tolerance of distance for adaptive simulation.",
				"unit": "Angstrom"
			}
		}
	},
	"SUB": {
		"cell": {
			"comment": {
				"type": "str",
				"default": "Structure information of system.",
				"note": "Subsystem(`SUB`_) use :ref:`cell-index<cell-index>` to define the atoms in the subsystem."
			},
			"dftpy": {
				"type": "str",
				"default": "cell",
				"comment": "cellfile"
			},
			"file": {
				"type": "str",
				"comment": "The file name of input structure. Many file formats are available. We use `ASE's I/O <https://wiki.fysik.dtu.dk/ase/ase/io/io.html#module-ase.io>`_ for some formats.",
				"default": null
			},
			"split": {
				"type": "floatlist",
				"comment": "Cut small cell for each direction (scaled).",
				"default": null
			},
			"cut": {
				"type": "floatlist",
				"comment": "Base on the subsystem atoms build the small cell, and add the vacuum on each direction. 0 means use whole cell.",
				"default": 0
			},
			"index": {
				"type": "intlist",
				"default": null,
				"comment": "The indices of the atoms, support integer and slice.",
				"note": "If not only a slice, you should given the stop for the slice."
			}
		},
		"grid": {
			"comment": {
				"type": "str",
				"default": "Control the grid."
			},
			"dftpy": {
				"type": "str",
				"default": "grid"
			},
			"ecut": {
				"type": "float",
				"default": null
			},
			"optfft": {
				"type": "bool",
				"default": true,
				"comment": "Optimize the number of grid points."
			},
			"shift": {
				"type": "intlist",
				"default": null,
				"comment": "The origin shift of grid to global grid.",
				"level": "devel"
			}
		},
		"density": {
			"comment": {
				"type": "str",
				"default": "Control the charge density."
			},
			"nspin": {
				"comment": "non/spin-polarized calculation.",
				"options": "1, 2",
				"type": "int",
				"level": "devel",
				"default": 1
			},
			"ncharge": {
				"type": "float",
				"comment": "Total charge of the system.",
				"default": null
			},
			"magmom": {
				"type": "float",
				"comment": "Total electronic magnetization.",
				"level": "devel",
				"default": null
			},
			"file": {
				"type": "str",
				"options": "",
				"comment": "The input density file for initial density. If set, the :ref:`density-initial<density-initial>` will automatically set to 'file'.",
				"default": null
			},
			"output": {
				"type": "str",
				"options": "",
				"comment": "The output file or format of density. The name starts with '.' represent the format.",
				"default": null
			},
			"initial": {
				"type": "lstr",
				"default": null,
				"options": "None, heg, temp, atomic, file",
				"comment": "Default is None, which means engines determine the initial density by themself. 'temp' means initial density from engine temporary output. 'atomic' means base on the atomic density files or pseudopotentials initialize the density. 'file' means use input density file :ref:`density-file<density-file>` to initialize the density."
			},
			"atomic": {
				"comment": "If :ref:`density-initial<density-initial>` set the Atomic, here can set each elements atomic density.",
				"type": "cdict",
				"default": {}
			},
			"use_gaussians": {
				"type": "bool",
				"default": false,
				"options": "True, False",
				"comment": " It will replaces the core densities of the surrounding fragments with a gaussian. This is to avoid problems of electrons leaking in the core region of surrounding fragments when hard pseudopotentials are employed."
			},
			"gaussians_rcut": {
				"type": "float",
				"default": 3,
				"options": "",
				"comment": "The cutoff of distance.",
				"unit": "Angstrom"
			},
			"gaussians_sigma": {
				"options": "",
				"comment": "The sigma of gaussians.",
				"type": "float",
				"default": 0.3
			},
			"gaussians_scale": {
				"options": "",
				"comment": "The scale of each elements. If not set, will use the number of core electrons.",
				"type": "cdict",
				"default": {}
			}
		},
		"exc": {
			"comment": {
				"type": "str",
				"default": "Control the exchange-correlation functional."
			},
			"dftpy": {
				"type": "str",
				"default": "exc",
				"comment": "x_str, c_str"
			},
			"libxc": {
				"type": "lstrlist",
				"default": null
			}
		},
		"kedf": {
			"dftpy": {
				"type": "str",
				"default": "kedf"
			}
		},
		"decompose": {
			"comment": {
				"type": "str",
				"default": "The way to decompose the subsystem to more subsystems"
			},
			"method": {
				"type": "str",
				"default": "manual",
				"comment": "'manual' means use the given subsystem; 'distance' means base on the distance of atoms to decompose the subsystem.",
				"options": "manual, distance"
			},
			"adaptive": {
				"type": "str",
				"default": "manual",
				"comment": "The decompose method after first step, 'manual' will remove all 'NSUB'.",
				"options": "manual, distance"
			},
			"rcut": {
				"type": "float",
				"default": 3,
				"comment": "The cutoff for decompose the subsystems.",
				"unit": "Angstrom"
			},
			"radius": {
				"type": "cfdict",
				"default": {},
				"comment": "The radius of each elements for decompose the subsystems.",
				"unit": "Angstrom"
			}
		},
		"mix": {
			"comment": {
				"type": "str",
				"default": "Control the charge density mixing."
			},
			"dftpy": {
				"type": "str",
				"default": "mix"
			},
			"scheme": {
				"type": "str",
				"default": null,
				"comment": "Density mixing scheme, default is with driver's own scheme.",
				"options": "Pulay, Linear"
			}
		},
		"opt": {
			"comment": {
				"type": "str",
				"default": "Control the charge density optimization for subsystem."
			},
			"dftpy": {
				"type": "str",
				"default": "opt"
			},
			"opt_method": {
				"type": "str",
				"level": "devel",
				"default": "full"
			},
			"maxiter": {
				"type": "int",
				"default": 800
			},
			"update_sleep": {
				"type": "int",
				"options": "",
				"comment": "Subsystem will wait several steps then update.",
				"default": "0"
			},
			"update_delay": {
				"type": "int",
				"options": "",
				"comment": "Delay several steps to evaluate the update frequency.",
				"default": "0"
			},
			"update_freq": {
				"type": "int",
				"options": "",
				"comment": "The update frequency of subsystem.",
				"default": "1"
			}
		},
		"kpoints": {
			"comment": {
				"type": "str",
				"default": "Set the kpoints for subsystem."
			},
			"method": {
				"type": "str",
				"options": "",
				"comment": "The method for generate the kpoints.",
				"default": "auto"
			},
			"grid": {
				"type": "intlist",
				"options": "",
				"comment": "The grid of kpoints.",
				"default": null
			},
			"offset": {
				"type": "floatlist",
				"options": "",
				"comment": "The offset of kpoints.",
				"default": null
			}
		},
		"subs": {
			"type": "strlist",
			"default": null,
			"level": "devel",
			"comment": "The name of all subsystems in this subsystem."
		},
		"calculator": {
			"type": "str",
			"default": "dftpy",
			"comment": "The SCF driver of subsystem.",
			"options": "dftpy, castep, qe"
		},
		"technique": {
			"type": "str",
			"default": "OF",
			"comment": "The technique (OF|KS) of the driver."
		},
		"nprocs": {
			"type": "float",
			"default": 1,
			"comment": "The number of processors for the subsystem.",
			"note": "If the minimum of all subsystems is 1, can also be used as ratio of number of processors for each subsystem."
		},
		"embed": {
			"type": "strlist",
			"default": "KE  XC",
			"comment": "The embedding potential.",
			"options": "KE, XC"
		},
		"embedpot": {
			"type": "str",
			"default": null,
			"comment": "The output file or format of embedding potential. The name starts with '.' represent the format.",
			"options": ""
		},
		"exttype": {
			"type": "int",
			"options": "0, 1,..., 7",
			"comment": "The embeded potential type, which is same as `embed`.",
			"level": "devel",
			"default": null
		},
		"basefile": {
			"type": "str",
			"options": "",
			"comment": "The base input file for subsystem.",
			"default": null
		},
		"prefix": {
			"type": "str",
			"options": "",
			"comment": "The prefix of each subsystem. If not set, it's same as the name of subsystem.",
			"default": null
		},
		"task": {
			"type": "str",
			"default": null,
			"comment": "The task to be performed for subsystem. Only works for JOB-task = Optmix.",
			"options": "scf, optical"
		}
	},
	"MOL": {
		"comment": {
			"type": "str",
			"default": "The information of molecules."
		},
		"charge": {
			"type": "ofdict",
			"default": {},
			"comment": "The charge of molecules or atoms."
		},
		"magmom": {
			"type": "ofdict",
			"default": {},
			"comment": "The magnetic moment of molecules or atoms."
		}
	}
}
